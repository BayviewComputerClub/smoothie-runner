// Code generated by protoc-gen-go. DO NOT EDIT.
// source: smoothie-runner.proto

/*
Package smoothie_runner is a generated protocol buffer package.

It is generated from these files:
	smoothie-runner.proto

It has these top-level messages:
	TestSolutionRequest
	Solution
	Problem
	ProblemGrader
	ProblemBatch
	ProblemBatchCase
	TestSolutionResponse
	TestCaseResult
*/
package smoothie_runner

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TestSolutionRequest struct {
	Solution              *Solution `protobuf:"bytes,1,opt,name=solution" json:"solution,omitempty"`
	TestBatchEvenIfFailed bool      `protobuf:"varint,2,opt,name=testBatchEvenIfFailed" json:"testBatchEvenIfFailed,omitempty"`
	CancelTesting         bool      `protobuf:"varint,3,opt,name=cancelTesting" json:"cancelTesting,omitempty"`
}

func (m *TestSolutionRequest) Reset()                    { *m = TestSolutionRequest{} }
func (m *TestSolutionRequest) String() string            { return proto.CompactTextString(m) }
func (*TestSolutionRequest) ProtoMessage()               {}
func (*TestSolutionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TestSolutionRequest) GetSolution() *Solution {
	if m != nil {
		return m.Solution
	}
	return nil
}

func (m *TestSolutionRequest) GetTestBatchEvenIfFailed() bool {
	if m != nil {
		return m.TestBatchEvenIfFailed
	}
	return false
}

func (m *TestSolutionRequest) GetCancelTesting() bool {
	if m != nil {
		return m.CancelTesting
	}
	return false
}

type Solution struct {
	Problem  *Problem `protobuf:"bytes,1,opt,name=problem" json:"problem,omitempty"`
	Language string   `protobuf:"bytes,2,opt,name=language" json:"language,omitempty"`
	Code     string   `protobuf:"bytes,3,opt,name=code" json:"code,omitempty"`
}

func (m *Solution) Reset()                    { *m = Solution{} }
func (m *Solution) String() string            { return proto.CompactTextString(m) }
func (*Solution) ProtoMessage()               {}
func (*Solution) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Solution) GetProblem() *Problem {
	if m != nil {
		return m.Problem
	}
	return nil
}

func (m *Solution) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Solution) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type Problem struct {
	TestBatches       []*ProblemBatch `protobuf:"bytes,1,rep,name=testBatches" json:"testBatches,omitempty"`
	ProblemID         uint64          `protobuf:"varint,2,opt,name=problemID" json:"problemID,omitempty"`
	TestCasesHashCode uint64          `protobuf:"varint,3,opt,name=testCasesHashCode" json:"testCasesHashCode,omitempty"`
	Grader            *ProblemGrader  `protobuf:"bytes,4,opt,name=grader" json:"grader,omitempty"`
}

func (m *Problem) Reset()                    { *m = Problem{} }
func (m *Problem) String() string            { return proto.CompactTextString(m) }
func (*Problem) ProtoMessage()               {}
func (*Problem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Problem) GetTestBatches() []*ProblemBatch {
	if m != nil {
		return m.TestBatches
	}
	return nil
}

func (m *Problem) GetProblemID() uint64 {
	if m != nil {
		return m.ProblemID
	}
	return 0
}

func (m *Problem) GetTestCasesHashCode() uint64 {
	if m != nil {
		return m.TestCasesHashCode
	}
	return 0
}

func (m *Problem) GetGrader() *ProblemGrader {
	if m != nil {
		return m.Grader
	}
	return nil
}

type ProblemGrader struct {
	Type       string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	CustomCode string `protobuf:"bytes,2,opt,name=customCode" json:"customCode,omitempty"`
}

func (m *ProblemGrader) Reset()                    { *m = ProblemGrader{} }
func (m *ProblemGrader) String() string            { return proto.CompactTextString(m) }
func (*ProblemGrader) ProtoMessage()               {}
func (*ProblemGrader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ProblemGrader) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ProblemGrader) GetCustomCode() string {
	if m != nil {
		return m.CustomCode
	}
	return ""
}

type ProblemBatch struct {
	Cases []*ProblemBatchCase `protobuf:"bytes,1,rep,name=cases" json:"cases,omitempty"`
}

func (m *ProblemBatch) Reset()                    { *m = ProblemBatch{} }
func (m *ProblemBatch) String() string            { return proto.CompactTextString(m) }
func (*ProblemBatch) ProtoMessage()               {}
func (*ProblemBatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ProblemBatch) GetCases() []*ProblemBatchCase {
	if m != nil {
		return m.Cases
	}
	return nil
}

type ProblemBatchCase struct {
	Input          string  `protobuf:"bytes,1,opt,name=input" json:"input,omitempty"`
	ExpectedAnswer string  `protobuf:"bytes,2,opt,name=expectedAnswer" json:"expectedAnswer,omitempty"`
	TimeLimit      float64 `protobuf:"fixed64,3,opt,name=timeLimit" json:"timeLimit,omitempty"`
	MemLimit       float64 `protobuf:"fixed64,4,opt,name=memLimit" json:"memLimit,omitempty"`
}

func (m *ProblemBatchCase) Reset()                    { *m = ProblemBatchCase{} }
func (m *ProblemBatchCase) String() string            { return proto.CompactTextString(m) }
func (*ProblemBatchCase) ProtoMessage()               {}
func (*ProblemBatchCase) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ProblemBatchCase) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

func (m *ProblemBatchCase) GetExpectedAnswer() string {
	if m != nil {
		return m.ExpectedAnswer
	}
	return ""
}

func (m *ProblemBatchCase) GetTimeLimit() float64 {
	if m != nil {
		return m.TimeLimit
	}
	return 0
}

func (m *ProblemBatchCase) GetMemLimit() float64 {
	if m != nil {
		return m.MemLimit
	}
	return 0
}

type TestSolutionResponse struct {
	TestCaseResult   *TestCaseResult `protobuf:"bytes,1,opt,name=testCaseResult" json:"testCaseResult,omitempty"`
	CompletedTesting bool            `protobuf:"varint,2,opt,name=completedTesting" json:"completedTesting,omitempty"`
	CompileError     string          `protobuf:"bytes,3,opt,name=compileError" json:"compileError,omitempty"`
}

func (m *TestSolutionResponse) Reset()                    { *m = TestSolutionResponse{} }
func (m *TestSolutionResponse) String() string            { return proto.CompactTextString(m) }
func (*TestSolutionResponse) ProtoMessage()               {}
func (*TestSolutionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TestSolutionResponse) GetTestCaseResult() *TestCaseResult {
	if m != nil {
		return m.TestCaseResult
	}
	return nil
}

func (m *TestSolutionResponse) GetCompletedTesting() bool {
	if m != nil {
		return m.CompletedTesting
	}
	return false
}

func (m *TestSolutionResponse) GetCompileError() string {
	if m != nil {
		return m.CompileError
	}
	return ""
}

type TestCaseResult struct {
	BatchNumber uint64  `protobuf:"varint,1,opt,name=batchNumber" json:"batchNumber,omitempty"`
	CaseNumber  uint64  `protobuf:"varint,2,opt,name=caseNumber" json:"caseNumber,omitempty"`
	Result      string  `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
	ResultInfo  string  `protobuf:"bytes,4,opt,name=resultInfo" json:"resultInfo,omitempty"`
	Time        float64 `protobuf:"fixed64,5,opt,name=time" json:"time,omitempty"`
	MemUsage    float64 `protobuf:"fixed64,6,opt,name=memUsage" json:"memUsage,omitempty"`
}

func (m *TestCaseResult) Reset()                    { *m = TestCaseResult{} }
func (m *TestCaseResult) String() string            { return proto.CompactTextString(m) }
func (*TestCaseResult) ProtoMessage()               {}
func (*TestCaseResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TestCaseResult) GetBatchNumber() uint64 {
	if m != nil {
		return m.BatchNumber
	}
	return 0
}

func (m *TestCaseResult) GetCaseNumber() uint64 {
	if m != nil {
		return m.CaseNumber
	}
	return 0
}

func (m *TestCaseResult) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *TestCaseResult) GetResultInfo() string {
	if m != nil {
		return m.ResultInfo
	}
	return ""
}

func (m *TestCaseResult) GetTime() float64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TestCaseResult) GetMemUsage() float64 {
	if m != nil {
		return m.MemUsage
	}
	return 0
}

func init() {
	proto.RegisterType((*TestSolutionRequest)(nil), "TestSolutionRequest")
	proto.RegisterType((*Solution)(nil), "Solution")
	proto.RegisterType((*Problem)(nil), "Problem")
	proto.RegisterType((*ProblemGrader)(nil), "ProblemGrader")
	proto.RegisterType((*ProblemBatch)(nil), "ProblemBatch")
	proto.RegisterType((*ProblemBatchCase)(nil), "ProblemBatchCase")
	proto.RegisterType((*TestSolutionResponse)(nil), "TestSolutionResponse")
	proto.RegisterType((*TestCaseResult)(nil), "TestCaseResult")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SmoothieRunnerAPI service

type SmoothieRunnerAPIClient interface {
	TestSolution(ctx context.Context, opts ...grpc.CallOption) (SmoothieRunnerAPI_TestSolutionClient, error)
}

type smoothieRunnerAPIClient struct {
	cc *grpc.ClientConn
}

func NewSmoothieRunnerAPIClient(cc *grpc.ClientConn) SmoothieRunnerAPIClient {
	return &smoothieRunnerAPIClient{cc}
}

func (c *smoothieRunnerAPIClient) TestSolution(ctx context.Context, opts ...grpc.CallOption) (SmoothieRunnerAPI_TestSolutionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SmoothieRunnerAPI_serviceDesc.Streams[0], c.cc, "/SmoothieRunnerAPI/TestSolution", opts...)
	if err != nil {
		return nil, err
	}
	x := &smoothieRunnerAPITestSolutionClient{stream}
	return x, nil
}

type SmoothieRunnerAPI_TestSolutionClient interface {
	Send(*TestSolutionRequest) error
	Recv() (*TestSolutionResponse, error)
	grpc.ClientStream
}

type smoothieRunnerAPITestSolutionClient struct {
	grpc.ClientStream
}

func (x *smoothieRunnerAPITestSolutionClient) Send(m *TestSolutionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *smoothieRunnerAPITestSolutionClient) Recv() (*TestSolutionResponse, error) {
	m := new(TestSolutionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SmoothieRunnerAPI service

type SmoothieRunnerAPIServer interface {
	TestSolution(SmoothieRunnerAPI_TestSolutionServer) error
}

func RegisterSmoothieRunnerAPIServer(s *grpc.Server, srv SmoothieRunnerAPIServer) {
	s.RegisterService(&_SmoothieRunnerAPI_serviceDesc, srv)
}

func _SmoothieRunnerAPI_TestSolution_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SmoothieRunnerAPIServer).TestSolution(&smoothieRunnerAPITestSolutionServer{stream})
}

type SmoothieRunnerAPI_TestSolutionServer interface {
	Send(*TestSolutionResponse) error
	Recv() (*TestSolutionRequest, error)
	grpc.ServerStream
}

type smoothieRunnerAPITestSolutionServer struct {
	grpc.ServerStream
}

func (x *smoothieRunnerAPITestSolutionServer) Send(m *TestSolutionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *smoothieRunnerAPITestSolutionServer) Recv() (*TestSolutionRequest, error) {
	m := new(TestSolutionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SmoothieRunnerAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "SmoothieRunnerAPI",
	HandlerType: (*SmoothieRunnerAPIServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TestSolution",
			Handler:       _SmoothieRunnerAPI_TestSolution_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "smoothie-runner.proto",
}

func init() { proto.RegisterFile("smoothie-runner.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 569 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0xdb, 0x6e, 0xd3, 0x40,
	0x10, 0x65, 0xa9, 0x93, 0xc6, 0x93, 0x0b, 0xcd, 0x92, 0x20, 0xab, 0x42, 0x28, 0xb2, 0xa0, 0x44,
	0x08, 0x0c, 0x0a, 0x48, 0x7d, 0x0e, 0xa1, 0x40, 0x24, 0x84, 0xaa, 0x6d, 0xe1, 0x11, 0xc9, 0x71,
	0xa6, 0x89, 0x25, 0xdb, 0x6b, 0x76, 0xd7, 0x5c, 0x7e, 0x81, 0x2f, 0xe0, 0x8d, 0x3f, 0xe0, 0x03,
	0xf8, 0x3a, 0xe4, 0xf5, 0xda, 0xb5, 0xd3, 0xbc, 0xcd, 0x9c, 0x33, 0xc9, 0x99, 0x39, 0x3b, 0x1e,
	0x18, 0xcb, 0x98, 0x73, 0xb5, 0x0d, 0xf1, 0x99, 0xc8, 0x92, 0x04, 0x85, 0x97, 0x0a, 0xae, 0xb8,
	0xfb, 0x9b, 0xc0, 0xdd, 0x4b, 0x94, 0xea, 0x82, 0x47, 0x99, 0x0a, 0x79, 0xc2, 0xf0, 0x6b, 0x86,
	0x52, 0xd1, 0x47, 0xd0, 0x91, 0x06, 0x72, 0xc8, 0x84, 0x4c, 0xbb, 0x33, 0xdb, 0xab, 0x6a, 0x2a,
	0x8a, 0xbe, 0x82, 0xb1, 0x42, 0xa9, 0x5e, 0xfb, 0x2a, 0xd8, 0x9e, 0x7d, 0xc3, 0x64, 0x79, 0xf5,
	0xd6, 0x0f, 0x23, 0x5c, 0x3b, 0xb7, 0x27, 0x64, 0xda, 0x61, 0xfb, 0x49, 0xfa, 0x10, 0xfa, 0x81,
	0x9f, 0x04, 0x18, 0xe5, 0xca, 0x61, 0xb2, 0x71, 0x0e, 0x74, 0x75, 0x13, 0x74, 0xbf, 0x40, 0xa7,
	0x54, 0xa4, 0x2e, 0x1c, 0xa6, 0x82, 0xaf, 0x22, 0x8c, 0x4d, 0x37, 0x1d, 0xef, 0xbc, 0xc8, 0x59,
	0x49, 0xd0, 0x63, 0xe8, 0x44, 0x7e, 0xb2, 0xc9, 0xfc, 0x0d, 0x6a, 0x79, 0x9b, 0x55, 0x39, 0xa5,
	0x60, 0x05, 0x7c, 0x8d, 0x5a, 0xc8, 0x66, 0x3a, 0x76, 0xff, 0x12, 0x38, 0x34, 0x7f, 0x42, 0x9f,
	0x43, 0xb7, 0x6a, 0x15, 0xa5, 0x43, 0x26, 0x07, 0xd3, 0xee, 0xac, 0x5f, 0x6a, 0x68, 0x98, 0xd5,
	0x2b, 0xe8, 0x7d, 0xb0, 0x8d, 0xee, 0xf2, 0x8d, 0x56, 0xb3, 0xd8, 0x35, 0x40, 0x9f, 0xc2, 0x30,
	0x2f, 0x5e, 0xf8, 0x12, 0xe5, 0x7b, 0x5f, 0x6e, 0x17, 0xa5, 0xb6, 0xc5, 0x6e, 0x12, 0xf4, 0x04,
	0xda, 0x1b, 0xe1, 0xaf, 0x51, 0x38, 0x96, 0x9e, 0x6d, 0x50, 0xea, 0xbe, 0xd3, 0x28, 0x33, 0xac,
	0xbb, 0x80, 0x7e, 0x83, 0xc8, 0xa7, 0x52, 0x3f, 0x53, 0xd4, 0x96, 0xd8, 0x4c, 0xc7, 0xf4, 0x01,
	0x40, 0x90, 0x49, 0xc5, 0x63, 0xad, 0x59, 0xf8, 0x50, 0x43, 0xdc, 0x53, 0xe8, 0xd5, 0xa7, 0xa2,
	0x8f, 0xa1, 0x15, 0xe4, 0xdd, 0x98, 0x99, 0x87, 0x8d, 0x99, 0xf3, 0x3e, 0x59, 0xc1, 0xbb, 0xbf,
	0x08, 0x1c, 0xed, 0x72, 0x74, 0x04, 0xad, 0x30, 0x49, 0x33, 0x65, 0x5a, 0x28, 0x12, 0x7a, 0x02,
	0x03, 0xfc, 0x91, 0x62, 0xa0, 0x70, 0x3d, 0x4f, 0xe4, 0x77, 0x14, 0xa6, 0x8f, 0x1d, 0x34, 0x37,
	0x51, 0x85, 0x31, 0x7e, 0x08, 0xe3, 0x50, 0x69, 0x7b, 0x08, 0xbb, 0x06, 0xf2, 0xf7, 0x8c, 0x31,
	0x2e, 0x48, 0x4b, 0x93, 0x55, 0xee, 0xfe, 0x21, 0x30, 0x6a, 0xae, 0xad, 0x4c, 0x79, 0x22, 0x91,
	0x9e, 0xc2, 0xa0, 0x34, 0x98, 0xa1, 0xcc, 0x22, 0x65, 0xf6, 0xe5, 0x8e, 0x77, 0xd9, 0x80, 0xd9,
	0x4e, 0x19, 0x7d, 0x02, 0x47, 0x01, 0x8f, 0xd3, 0x08, 0x15, 0xae, 0xcb, 0xb5, 0x2c, 0x96, 0xf8,
	0x06, 0x4e, 0x5d, 0xe8, 0xe5, 0x58, 0x18, 0xe1, 0x99, 0x10, 0x5c, 0x98, 0xad, 0x6a, 0x60, 0xee,
	0x3f, 0x02, 0x83, 0xa6, 0x24, 0x9d, 0x40, 0x77, 0x95, 0x3b, 0xf7, 0x31, 0x8b, 0x57, 0x28, 0x74,
	0x63, 0x16, 0xab, 0x43, 0xfa, 0xf1, 0x7c, 0x89, 0xa6, 0xa0, 0x58, 0xab, 0x1a, 0x42, 0xef, 0x41,
	0x5b, 0x14, 0x53, 0x15, 0x92, 0x26, 0xcb, 0x7f, 0x57, 0x44, 0xcb, 0xe4, 0x8a, 0x6b, 0xb3, 0x6c,
	0x56, 0x43, 0xf4, 0xa2, 0x84, 0x31, 0x3a, 0x2d, 0x6d, 0xa3, 0x8e, 0x8d, 0xbd, 0x9f, 0x64, 0xfe,
	0xb9, 0xb4, 0x2b, 0x7b, 0x75, 0x3e, 0xfb, 0x0c, 0xc3, 0x0b, 0x73, 0x2e, 0x98, 0xbe, 0x16, 0xf3,
	0xf3, 0x25, 0x9d, 0x43, 0xaf, 0x6e, 0x39, 0x1d, 0x79, 0x7b, 0x0e, 0xc7, 0xf1, 0xd8, 0xdb, 0xf7,
	0x2e, 0xee, 0xad, 0x29, 0x79, 0x41, 0x56, 0x6d, 0x7d, 0x74, 0x5e, 0xfe, 0x0f, 0x00, 0x00, 0xff,
	0xff, 0x10, 0x86, 0x56, 0x6c, 0x8d, 0x04, 0x00, 0x00,
}
